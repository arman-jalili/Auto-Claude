# Step 10: Testing and Validation

## Objective
Create comprehensive testing plan for OpenCode CLI integration, including unit tests, integration tests, and manual testing procedures.

## Testing Strategy

### Phase 1: Backend Unit Tests

#### Test 1: CLI Manager

**File**: `tests/core/test_cli_manager.py`

```python
import os
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock

from core.cli_manager import (
    CLIManager,
    CLIType,
    CLIProvider,
    get_cli_manager,
)


class TestCLIManager:
    def test_default_cli_type(self, tmp_path):
        """Test default CLI type is Claude."""
        manager = CLIManager(tmp_path)
        assert manager.get_cli_type() == CLIType.CLAUDE

    def test_env_var_cli_type_claude(self, tmp_path):
        """Test Claude CLI type from environment variable."""
        with patch.dict(os.environ, {"CLI_PROVIDER": "claude"}):
            manager = CLIManager(tmp_path)
            assert manager.get_cli_type() == CLIType.CLAUDE

    def test_env_var_cli_type_opencode(self, tmp_path):
        """Test OpenCode CLI type from environment variable."""
        with patch.dict(os.environ, {"CLI_PROVIDER": "opencode"}):
            manager = CLIManager(tmp_path)
            assert manager.get_cli_type() == CLIType.OPENCODE

    def test_settings_file_cli_type(self, tmp_path):
        """Test CLI type from settings file."""
        import json
        settings_file = tmp_path / ".auto-claude" / "settings.json"
        settings_file.parent.mkdir(parents=True, exist_ok=True)

        with open(settings_file, "w") as f:
            json.dump({"cli": "opencode"}, f)

        manager = CLIManager(tmp_path)
        assert manager.get_cli_type() == CLIType.OPENCODE

    def test_find_claude_cli(self, tmp_path):
        """Test finding Claude Code CLI."""
        with patch("shutil.which") as mock_which:
            mock_which.return_value = "/usr/local/bin/claude"
            manager = CLIManager(tmp_path)
            path = manager.get_cli_path()
            assert path == Path("/usr/local/bin/claude")

    def test_find_opencode_cli(self, tmp_path):
        """Test finding OpenCode CLI."""
        with patch.dict(os.environ, {"CLI_PROVIDER": "opencode"}):
            with patch("shutil.which") as mock_which:
                mock_which.return_value = "/usr/local/bin/opencode"
                manager = CLIManager(tmp_path)
                path = manager.get_cli_path()
                assert path == Path("/usr/local/bin/opencode")

    def test_cli_not_found(self, tmp_path):
        """Test handling when CLI is not found."""
        with patch("shutil.which") as mock_which:
            mock_which.return_value = None
            manager = CLIManager(tmp_path)
            assert manager.get_cli_path() is None

    def test_validate_working_cli(self, tmp_path):
        """Test validation of working CLI."""
        with patch("shutil.which") as mock_which:
            mock_which.return_value = "/usr/local/bin/claude"
            with patch("subprocess.run") as mock_run:
                mock_run.return_value = MagicMock(
                    returncode=0,
                    stdout="1.0.0\n",
                    stderr=""
                )
                manager = CLIManager(tmp_path)
                is_valid, message = manager.validate_cli()
                assert is_valid is True
                assert "1.0.0" in message

    def test_validate_missing_cli(self, tmp_path):
        """Test validation when CLI is missing."""
        with patch("shutil.which") as mock_which:
            mock_which.return_value = None
            manager = CLIManager(tmp_path)
            is_valid, message = manager.validate_cli()
            assert is_valid is False
            assert "not found" in message.lower()

    def test_auth_info_claude(self, tmp_path):
        """Test auth info for Claude CLI."""
        with patch.dict(os.environ, {}, clear=True):
            manager = CLIManager(tmp_path)
            auth_info = manager.get_auth_info()
            assert auth_info["cli"] == "claude"
            assert auth_info["requires_oauth"] is True
            assert "providers" not in auth_info

    def test_auth_info_opencode(self, tmp_path):
        """Test auth info for OpenCode CLI."""
        with patch.dict(os.environ, {"CLI_PROVIDER": "opencode"}):
            manager = CLIManager(tmp_path)
            auth_info = manager.get_auth_info()
            assert auth_info["cli"] == "opencode"
            assert auth_info["requires_oauth"] is False
            assert auth_info["supports_keychain"] is True
            assert "providers" in auth_info
            assert isinstance(auth_info["providers"], list)

    def test_opencode_provider_default(self, tmp_path):
        """Test default OpenCode provider is Claude."""
        with patch.dict(os.environ, {"CLI_PROVIDER": "opencode"}):
            with patch("shutil.which") as mock_which:
                mock_which.return_value = "/usr/local/bin/opencode"
                manager = CLIManager(tmp_path)
                provider = manager.get_opencode_provider()
                assert provider == CLIProvider.CLAUDE

    def test_opencode_provider_from_env(self, tmp_path):
        """Test OpenCode provider from environment."""
        with patch.dict(os.environ, {
            "CLI_PROVIDER": "opencode",
            "OPENCODE_PROVIDER": "openai"
        }):
            manager = CLIManager(tmp_path)
            provider = manager.get_opencode_provider()
            assert provider == CLIProvider.OPENAI
```

#### Test 2: OpenCode Authentication

**File**: `tests/core/test_opencode_auth.py`

```python
import os
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock, mock_open
import json

from core.auth import (
    get_opencode_token,
    get_auth_token_by_cli_type,
    trigger_opencode_login,
)


class TestOpenCodeAuth:
    def test_get_token_from_env_var(self):
        """Test getting OpenCode token from environment variable."""
        token = "sk-opc-test-key-12345"
        with patch.dict(os.environ, {"OPENCODE_API_KEY": token}):
            result = get_opencode_token()
            assert result == token

    def test_get_token_from_config_file(self, tmp_path):
        """Test getting OpenCode token from config file."""
        token = "sk-opc-config-key-67890"
        opencode_config = tmp_path / ".opencode" / "config.json"
        opencode_config.parent.mkdir(parents=True, exist_ok=True)

        with open(opencode_config, "w") as f:
            json.dump({"apiKey": token}, f)

        with patch.dict(os.environ, {}, clear=True):
            result = get_opencode_token(str(tmp_path))
            assert result == token

    def test_get_token_from_project_settings(self, tmp_path):
        """Test getting OpenCode token from project settings."""
        token = "sk-opc-project-key-11111"
        settings_dir = tmp_path / ".auto-claude"
        settings_dir.mkdir(parents=True, exist_ok=True)

        settings_file = settings_dir / "settings.json"
        with open(settings_file, "w") as f:
            json.dump({
                "opencode": {
                    "apiKey": token
                }
            }, f)

        result = get_opencode_token(str(tmp_path))
        assert result == token

    def test_get_token_not_found(self, tmp_path):
        """Test when OpenCode token is not found."""
        with patch.dict(os.environ, {}, clear=True):
            result = get_opencode_token(str(tmp_path))
            assert result is None

    def test_auth_token_by_cli_type_claude(self):
        """Test getting auth token for Claude CLI."""
        claude_token = "sk-ant-test-claude-token"
        with patch.dict(os.environ, {"CLAUDE_CODE_OAUTH_TOKEN": claude_token}):
            result = get_auth_token_by_cli_type("claude")
            assert result == claude_token

    def test_auth_token_by_cli_type_opencode(self):
        """Test getting auth token for OpenCode CLI."""
        opencode_token = "sk-opc-test-opencode-token"
        with patch.dict(os.environ, {"OPENCODE_API_KEY": opencode_token}):
            result = get_auth_token_by_cli_type("opencode")
            assert result == opencode_token

    def test_trigger_opencode_login(self, capsys):
        """Test triggering OpenCode login flow."""
        with patch.dict(os.environ, {}, clear=True):
            result = trigger_opencode_login()
            assert result is False  # Returns False (manual login required)

        # Check output contains guidance
        captured = capsys.readouterr()
        assert "opencode login" in captured
        assert "provider" in captured
```

### Phase 2: Frontend Unit Tests

#### Test 3: CLI Handlers

**File**: `apps/frontend/src/main/ipc-handlers/__tests__/cli-handlers.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { ipcMain } from 'electron';

describe('CLI Handlers', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should register all CLI handlers', () => {
    const { registerCLIHandlers } = await import('../cli-handlers');
    const mockMainWindow = vi.fn();

    registerCLIHandlers(mockMainWindow);

    // Verify handlers are registered
    expect(ipcMain.handle).toHaveBeenCalledWith('CLI_GET_INFO');
    expect(ipcMain.handle).toHaveBeenCalledWith('CLI_SET_CLI');
    expect(ipcMain.handle).toHaveBeenCalledWith('CLI_VALIDATE_CLI');
    expect(ipcMain.handle).toHaveBeenCalledWith('CLI_GET_PROVIDERS');
  });

  it('should get CLI info successfully', async () => {
    const mockProjectPath = '/path/to/project';
    const mockSettings = { cli: 'claude' };
    const mockPythonEnvManager = {
      getProjectPath: () => mockProjectPath,
    };

    const mockProjectStore = {
      getSettings: vi.fn().mockResolvedValue(mockSettings),
    };

    vi.doMock('../project-store', () => mockProjectStore);
    vi.doMock('../python-env-manager', () => mockPythonEnvManager);

    const { getCLIInfo } = await import('../cli-handlers');
    const info = await getCLIInfo();

    expect(info.type).toBe('claude');
    expect(info.isValid).toBeDefined();
  });

  it('should set CLI options successfully', async () => {
    const options = { cliType: 'opencode' as const };
    const mockResult = {
      success: true,
      data: {
        type: 'opencode',
        isValid: true,
        path: '/usr/local/bin/opencode',
        authInfo: {
          type: 'multi_provider',
          providers: ['claude', 'openai'],
        },
      },
    };

    const mockPythonEnvManager = {
      runPythonScript: vi.fn().mockResolvedValue({
        stdout: JSON.stringify(mockResult.data),
      }),
    };

    const mockProjectStore = {
      getSettings: vi.fn(),
      saveSettings: vi.fn().mockResolvedValue(undefined),
    };

    vi.doMock('../python-env-manager', () => mockPythonEnvManager);
    vi.doMock('../project-store', () => mockProjectStore);

    const { setCLIOptions } = await import('../cli-handlers');
    const result = await setCLIOptions(options);

    expect(result.success).toBe(true);
    expect(mockProjectStore.saveSettings).toHaveBeenCalled();
  });

  it('should validate CLI', async () => {
    const mockValidationResult = {
      isValid: true,
      message: 'opencode CLI is working (version: 1.0.0)',
    };

    const mockCLIInfo = {
      type: 'opencode',
      isValid: true,
    };

    const mockGetCLIInfo = vi.fn().mockResolvedValue({
      success: true,
      data: mockCLIInfo,
    });

    const mockValidateCLI = vi.fn().mockResolvedValue({
      success: true,
      data: mockValidationResult,
    });

    vi.doMock('../cli-handlers', () => ({
      getCLIInfo: mockGetCLIInfo,
      validateCLI: mockValidateCLI,
    }));

    const { validateCLI } = await import('../cli-handlers');
    const result = await validateCLI();

    expect(result.success).toBe(true);
    expect(result.data).toEqual(mockValidationResult);
  });

  it('should get OpenCode providers', () => {
    const { getOpenCodeProviders } = await import('../cli-handlers');
    const providers = getOpenCodeProviders();

    expect(Array.isArray(providers)).toBe(true);
    expect(providers.length).toBeGreaterThan(0);
    expect(providers[0]).toHaveProperty('id');
    expect(providers[0]).toHaveProperty('name');
    expect(providers[0]).toHaveProperty('displayName');
  });
});
```

#### Test 4: CLI Selector Component

**File**: `apps/frontend/src/renderer/features/settings/__tests__/cli-selector.test.tsx`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { renderHook } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('CLISelector Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should render CLI selection dropdown', () => {
    const mockCLIAPI = {
      getInfo: vi.fn().mockResolvedValue({
        success: true,
        data: {
          type: 'claude',
          isValid: true,
          path: '/usr/local/bin/claude',
          authInfo: {
            type: 'oauth',
            requiresOAuth: true,
          },
        },
      }),
    };

    vi.doMock('@preload/api/modules/cli-api', () => mockCLIAPI);

    const { result } = renderHook(() => <CLISelector />);

    await waitFor(() => {
      const select = result.container.querySelector('#cli-type') as HTMLSelectElement;
      expect(select).toBeDefined();
      expect(select.value).toBe('claude');
    });
  });

  it('should switch to OpenCode when selected', async () => {
    const mockCLIAPI = {
      getInfo: vi.fn().mockResolvedValue({
        success: true,
        data: {
          type: 'claude',
          isValid: true,
        },
      }),
      setCLI: vi.fn().mockResolvedValue({
        success: true,
        data: {
          type: 'opencode',
          isValid: true,
          path: '/usr/local/bin/opencode',
          authInfo: {
            type: 'multi_provider',
            providers: ['claude'],
          },
        },
      }),
    };

    vi.doMock('@preload/api/modules/cli-api', () => mockCLIAPI);

    const { result } = renderHook(() => <CLISelector />);
    const user = userEvent.setup();

    const select = result.container.querySelector('#cli-type') as HTMLSelectElement;

    await act(async () => {
      await user.selectOptions(select, 'opencode');
    });

    await waitFor(() => {
      expect(mockCLIAPI.setCLI).toHaveBeenCalledWith({
        cliType: 'opencode',
      });
      expect(result.current).toEqual({
        type: 'opencode',
        path: '/usr/local/bin/opencode',
        isValid: true,
      });
    });
  });

  it('should show provider selector when OpenCode is active', async () => {
    const mockCLIAPI = {
      getInfo: vi.fn().mockResolvedValue({
        success: true,
        data: {
          type: 'opencode',
          isValid: true,
          authInfo: {
            providers: [
              { id: 'claude', name: 'claude', displayName: 'Claude', authType: 'oauth' },
              { id: 'openai', name: 'openai', displayName: 'OpenAI (GPT)', authType: 'oauth' },
            ],
          },
        },
      }),
    };

    vi.doMock('@preload/api/modules/cli-api', () => mockCLIAPI);

    const { result } = renderHook(() => <CLISelector />);

    await waitFor(() => {
      const providerSelect = result.container.querySelector('#opencode-provider') as HTMLSelectElement;
      expect(providerSelect).toBeDefined();
    });
  });

  it('should handle provider change', async () => {
    const mockCLIAPI = {
      getInfo: vi.fn().mockResolvedValue({
        success: true,
        data: {
          type: 'opencode',
          authInfo: {
            providers: [
              { id: 'claude', name: 'claude' },
              { id: 'openai', name: 'openai' },
            ],
          },
        },
      }),
      setCLI: vi.fn().mockResolvedValue({
        success: true,
        data: {
          type: 'opencode',
          authInfo: {
            providers: [
              { id: 'claude', name: 'claude' },
              { id: 'openai', name: 'openai' },
            ],
          },
        },
      }),
    };

    vi.doMock('@preload/api/modules/cli-api', () => mockCLIAPI);

    const { result } = renderHook(() => <CLISelector />);
    const user = userEvent.setup();

    const providerSelect = result.container.querySelector('#opencode-provider') as HTMLSelectElement;

    await act(async () => {
      await user.selectOptions(providerSelect, 'openai');
    });

    await waitFor(() => {
      expect(mockCLIAPI.setCLI).toHaveBeenCalledTimes(2);
      expect(mockCLIAPI.setCLI).toHaveBeenNthCalledWith(1, { cliType: 'opencode' });
      expect(mockCLIAPI.setCLI).toHaveBeenNthCalledWith(2, {
        cliType: 'opencode',
        opencodeProvider: 'openai',
      });
    });
  });

  it('should test CLI connection', async () => {
    const mockCLIAPI = {
      validateCLI: vi.fn().mockResolvedValue({
        success: true,
        data: {
          isValid: true,
          message: 'claude CLI is working',
        },
      }),
    };

    vi.doMock('@preload/api/modules/cli-api', () => mockCLIAPI);

    const { result } = renderHook(() => <CLISelector />);
    const user = userEvent.setup();

    const testButton = result.container.querySelector('button') as HTMLButtonElement;

    await act(async () => {
      await user.click(testButton);
    });

    await waitFor(() => {
      expect(mockCLIAPI.validateCLI).toHaveBeenCalled();
    });
  });
});
```

### Phase 3: Integration Tests

#### Test 5: CLI Selection Integration

**File**: `tests/integration/test_cli_selection.py`

```python
import os
import pytest
import tempfile
import shutil
from pathlib import Path

from core.cli_manager import CLIManager, CLIType
from core.auth import get_auth_token_by_cli_type


class TestCLISelectionIntegration:
    def test_switch_from_claude_to_opencode(self, tmp_path):
        """Test switching CLI from Claude to OpenCode."""
        # Set OpenCode in environment
        os.environ["CLI_PROVIDER"] = "opencode"
        os.environ["OPENCODE_PROVIDER"] = "claude"
        os.environ["OPENCODE_API_KEY"] = "sk-opc-test-key"

        manager = CLIManager(tmp_path)

        # Verify CLI type changed
        assert manager.get_cli_type() == CLIType.OPENCODE

        # Verify OpenCode provider is set
        assert manager.get_opencode_provider().value == "claude"

    def test_settings_file_priority(self, tmp_path):
        """Test that settings file takes priority over environment."""
        settings_dir = tmp_path / ".auto-claude"
        settings_dir.mkdir(parents=True, exist_ok=True)

        # Create settings file with Claude CLI
        settings_file = settings_dir / "settings.json"
        with open(settings_file, "w") as f:
            import json
            json.dump({"cli": "claude"}, f)

        # Set environment to OpenCode
        os.environ["CLI_PROVIDER"] = "opencode"

        manager = CLIManager(tmp_path)

        # Settings should take priority
        assert manager.get_cli_type() == CLIType.CLAUDE

    def test_cli_validation_integration(self, tmp_path, monkeypatch):
        """Test CLI validation works end-to-end."""
        # Mock subprocess to simulate a working CLI
        mock_subprocess_result = type('MockSubprocessResult', (object)())
        mock_subprocess_result.returncode = 0
        mock_subprocess_result.stdout = "1.0.0"
        mock_subprocess_result.stderr = ""

        monkeypatch.setattr(
            "subprocess.run",
            lambda *args, **kwargs: mock_subprocess_result
        )

        os.environ["CLI_PROVIDER"] = "claude"

        manager = CLIManager(tmp_path)
        is_valid, message = manager.validate_cli()

        assert is_valid is True
        assert "1.0.0" in message
```

### Phase 4: Manual Testing Procedures

#### Manual Test 1: CLI Installation Verification

```bash
# Test 1: Verify Claude Code CLI installation
which claude
claude --version

# Test 2: Verify OpenCode CLI installation
which opencode
opencode --version

# Test 3: Check Auto Claude CLI detection
python run.py --info

# Expected output:
# ============================================================
# CLI Configuration
# ============================================================
# CLI Type: claude
# CLI Path: /usr/local/bin/claude
# Auth Type: oauth
# ============================================================
```

#### Manual Test 2: CLI Switching

```bash
# Test 1: Switch to OpenCode via flag
python run.py --cli opencode --info

# Test 2: Switch to OpenCode via environment
export CLI_PROVIDER=opencode
python run.py --info

# Test 3: Switch to OpenCode via settings file
cd your-project
echo '{"cli":"opencode","opencode":{"provider":"claude"}}' > .auto-claude/settings.json
python run.py --info

# Test 4: Switch back to Claude (default)
export CLI_PROVIDER=claude
python run.py --info
```

#### Manual Test 3: Full Workflow with OpenCode

```bash
# Prerequisites: Install OpenCode
npm install -g opencode-ai

# Step 1: Create a simple project
mkdir -p test-opencode
cd test-opencode
git init
echo "# Test Project" > README.md

# Step 2: Create spec with Auto Claude using OpenCode
export CLI_PROVIDER=opencode
export OPENCODE_PROVIDER=claude
# (OpenCode CLI will use its own auth, but we're selecting Claude provider)

cd ..
python spec_runner.py --task "Add a hello function" --interactive
# Select options and create spec

# Step 3: Run the spec with OpenCode
python run.py --spec 001

# Step 4: Verify build completed
# Check that work was done correctly
```

#### Manual Test 4: Authentication Flows

```bash
# Test 1: Claude Code authentication (baseline)
claude login
# Follow OAuth flow
python run.py --info

# Test 2: OpenCode with Claude provider
opencode login
# Select Claude as provider
python run.py --cli opencode --info

# Test 3: OpenCode with OpenAI provider
opencode login
# Select OpenAI as provider
export OPENCODE_PROVIDER=openai
python run.py --cli opencode --info

# Test 4: OpenCode Zen (API key)
opencode login
# Sign up at https://opencode.ai/zen
# Get API key
opencode config apiKey YOUR_KEY
python run.py --cli opencode --info
```

### Phase 5: End-to-End Testing

#### Test 6: Complete Auto Claude Workflow

1. **Desktop App Testing**:
   - Open Auto Claude in development mode
   - Go to Settings â†’ AI CLI
   - Switch to OpenCode
   - Test provider selection (Claude, OpenAI, Google, Zen, Local)
   - Click "Test Connection"
   - Verify validation messages
   - Create a new project
   - Create and run a spec
   - Verify execution with OpenCode
   - Switch back to Claude Code
   - Run another task to verify

2. **CLI Testing**:
   - Run all commands with both CLIs
   - Test with different providers
   - Test error handling (invalid CLI, missing auth)
   - Test environment variable overrides
   - Test settings file persistence

3. **Cross-Platform Testing**:
   - macOS: Test with Claude Code CLI and OpenCode CLI
   - Windows: Test with Claude Code CLI and OpenCode CLI
   - Linux: Test with Claude Code CLI and OpenCode CLI

## Test Execution Commands

```bash
# Backend tests
cd apps/backend
pytest tests/core/test_cli_manager.py -v
pytest tests/core/test_opencode_auth.py -v

# Frontend tests
cd apps/frontend
npm test -- cli-handlers
npm test -- cli-selector

# Type checking
npm run typecheck

# Linting
npm run lint:fix
```

## Test Coverage Goals

| Test Suite | Target Coverage |
|-----------|---------------|
| CLI Manager Unit Tests | 90% |
| OpenCode Auth Unit Tests | 85% |
| CLI Handlers Unit Tests | 80% |
| CLI Selector Component Tests | 85% |
| Integration Tests | 70% |
| Manual Testing Checklist | 100% |

## Success Criteria

The OpenCode integration is complete when:

### Backend
- [x] CLI Manager detects both Claude and OpenCode
- [x] CLI validation works for both CLIs
- [ ] OpenCode authentication retrieves tokens from multiple sources
- [ ] Client integration respects CLI type
- [ ] CLI selection works in run.py (--cli flag)
- [ ] All unit tests pass

### Frontend
- [x] IPC handlers registered and working
- [x] CLI selector component displays correctly
- [ ] CLI settings persist to .auto-claude/settings.json
- [ ] All i18n translations added
- [ ] CLI preload API functions work
- [ ] Settings updated to support CLI configuration
- [ ] All component tests pass

### Integration
- [ ] CLI can be switched via UI
- [ ] CLI can be switched via command line
- [ ] CLI can be switched via environment variable
- [ ] CLI can be switched via settings file
- [ ] OpenCode providers can be selected
- [ ] Connection testing works for both CLIs
- [ ] Full workflow works with OpenCode

### Documentation
- [ ] README.md updated with OpenCode installation
- [ ] OPENCODE.md guide created
- [ ] Troubleshooting section added
- [ ] Examples provided for common workflows
- [ ] Architecture documentation updated

## Blockers and Issues

| Issue | Status | Resolution |
|-------|--------|------------|
| OpenCode CLI keychain format | Unknown | Research OpenCode source code |
| Model selection integration | Unknown | May need CLI integration for model UI |
| Rate limit differences | Expected | Document in troubleshooting |

## Verification Commands

```bash
# Run all tests
cd apps/frontend && npm test
cd apps/backend && pytest tests/ -v

# Build the app
npm run build

# Type check
npm run typecheck

# Lint
npm run lint:fix
```

## Next Steps

After completing all tests:

1. **Fix any failing tests**
2. **Address test coverage gaps**
3. **Create PR with changes**
4. **Update project tracking documents**

## Summary

This step provides comprehensive testing for the OpenCode integration, covering:

1. **Unit Tests**: Backend and frontend
2. **Integration Tests**: CLI selection and validation
3. **Manual Testing**: End-user workflows
4. **Cross-Platform Testing**: macOS, Windows, Linux

All test files follow existing patterns in the codebase and use Vitest/pytest as appropriate.
